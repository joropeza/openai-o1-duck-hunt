<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Duck Hunt Marsh (Square)</title>
  <style>
    /* Container to limit width to 800px */
    .game-container {
      max-width: 800px;
      margin: 0 auto;
      border: 2px solid #555;
      position: relative;
    }

    /* Let JavaScript control the exact canvas dimensions for 1:1 aspect ratio */
    canvas {
      display: block;
      width: 100%;
      cursor: none;
      /* We'll draw a custom crosshair */
    }

    body {
      margin: 0;
      padding: 0;
      background: #eee;
      font-family: sans-serif;
    }
  </style>
</head>

<body>

  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>

  <script>
    /** 
     * Gun class to handle aiming and firing.
     */
    class Gun {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.isFiring = false;
        this.flashTimer = 0;
        this.flashDuration = 200; // milliseconds
      }

      update(deltaTime) {
        if (this.isFiring) {
          this.flashTimer -= deltaTime;
          if (this.flashTimer <= 0) {
            this.isFiring = false;
            this.flashTimer = 0;
          }
        }
      }

      fire() {
        this.isFiring = true;
        this.flashTimer = this.flashDuration;
      }

      setPosition(x, y) {
        this.x = x;
        this.y = y;
      }

      draw(ctx) {
        ctx.save();
        ctx.strokeStyle = this.isFiring ? "red" : "black";
        ctx.lineWidth = 2;

        const size = 20;
        // Crosshair lines
        ctx.beginPath();
        ctx.moveTo(this.x - size, this.y);
        ctx.lineTo(this.x + size, this.y);
        ctx.moveTo(this.x, this.y - size);
        ctx.lineTo(this.x, this.y + size);
        ctx.stroke();

        // Small circle in the center
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      }
    }

    /**
     * Duck class for creating and updating a flying duck with a sprite.
     */
    class Duck {
      static duckImage = null;

      constructor(canvasWidth, canvasHeight) {
        // If you haven't loaded the image yet, load it once
        if (!Duck.duckImage) {
          Duck.duckImage = new Image();
          Duck.duckImage.src = "https://seeklogo.com/images/D/Duck_Hunt-logo-8044A0A3B6-seeklogo.com.png";
        }

        // Randomly decide direction
        // true => left->right, false => right->left
        this.flyRight = Math.random() < 0.5;
        const randomY = Math.random() * (canvasHeight - 60) + 30; // keep duck mostly in view

        // Position
        if (this.flyRight) {
          // Start just off the left edge
          this.x = -50;
          this.vx = 0.3; // ~0.3px per ms => 300px/sec
        } else {
          // Start just off the right edge
          this.x = canvasWidth + 50;
          this.vx = -0.3;
        }
        this.y = randomY;
        this.width = 50;
        this.height = 50; // For collisions or scaling, if needed
        this.alive = true; // Mark if the duck is active
      }

      update(deltaTime, canvasWidth) {
        // Move horizontally
        this.x += this.vx * deltaTime;

        // If the duck has gone off screen, mark it inactive
        if (this.flyRight && this.x > canvasWidth + 50) {
          this.alive = false;
        } else if (!this.flyRight && this.x < -100) {
          this.alive = false;
        }
      }

      draw(ctx) {
        // If the image isn't loaded yet, do nothing
        if (!Duck.duckImage.complete) return;

        ctx.save();
        if (!this.flyRight) {
          // Flip horizontally if flying left
          ctx.translate(this.x, this.y);
          ctx.scale(-1, 1);
          // Move the draw origin so the image is drawn at 0,0 post-scale
          ctx.drawImage(Duck.duckImage, -this.width / 2, -this.height / 2, this.width, this.height);
        } else {
          // Flying right => no flip
          ctx.translate(this.x, this.y);
          ctx.drawImage(Duck.duckImage, -this.width / 2, -this.height / 2, this.width, this.height);
        }
        ctx.restore();
      }
    }

    /**
     * Shell class (placeholder).
     */
    class Shell {
      constructor() {
        // Not used here, but left for structure
      }
      update(deltaTime) { }
      draw(ctx) { }
    }

    /** 
     * Main Game class
     */
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.lastTime = 0;

        this.gun = new Gun();
        this.shells = [];
        this.ducks = [];

        // For duck spawning
        this.duckSpawnTimer = 0;
        this.nextDuckSpawnTime = this.randomSpawnTime(); // ms between 3 & 7s

        canvas.addEventListener("mousemove", (e) => this.onMouseMove(e));
        canvas.addEventListener("mousedown", (e) => this.onMouseDown(e));

        this.resizeCanvas();
        window.addEventListener("resize", () => this.resizeCanvas());

        requestAnimationFrame((time) => this.gameLoop(time));
      }

      // Random spawn delay between 3s and 7s
      randomSpawnTime() {
        return 3000 + Math.random() * 4000;
      }

      resizeCanvas() {
        const containerRect = this.canvas.parentNode.getBoundingClientRect();
        // keep the canvas square
        const size = containerRect.width;
        this.canvas.width = size;
        this.canvas.height = size;
      }

      onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.gun.setPosition(x, y);
      }

      onMouseDown(e) {
        this.gun.fire();
        // In a real game, you might check if a duck was clicked, etc.
      }

      gameLoop(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame((time) => this.gameLoop(time));
      }

      update(deltaTime) {
        // Update gun
        this.gun.update(deltaTime);

        // Update duck spawn timing
        this.duckSpawnTimer += deltaTime;
        if (this.duckSpawnTimer >= this.nextDuckSpawnTime) {
          this.spawnDuck();
          this.duckSpawnTimer = 0;
          this.nextDuckSpawnTime = this.randomSpawnTime();
        }

        // Update ducks
        this.ducks.forEach(duck => duck.update(deltaTime, this.canvas.width));
        // Remove ducks that have gone offscreen
        this.ducks = this.ducks.filter(duck => duck.alive);

        // Shells if needed
        this.shells.forEach(shell => shell.update(deltaTime));
      }

      spawnDuck() {
        const newDuck = new Duck(this.canvas.width, this.canvas.height);
        this.ducks.push(newDuck);
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Background
        this.drawBackground();
        // Trees
        this.drawTrees();

        // Ducks
        this.ducks.forEach(duck => duck.draw(this.ctx));

        // Gun crosshair
        this.gun.draw(this.ctx);
      }

      drawBackground() {
        const { width, height } = this.canvas;
        const ctx = this.ctx;

        // Sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, "#72c2f2");
        skyGradient.addColorStop(0.7, "#b3ecff");
        skyGradient.addColorStop(1, "#ffffff");
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);

        // Green floor
        const floorHeight = height * 0.3;
        ctx.fillStyle = "#5cbb4e";
        ctx.fillRect(0, height - floorHeight, width, floorHeight);
      }

      drawTrees() {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const treeCount = 5;
        const floorHeight = height * 0.3;

        for (let i = 0; i < treeCount; i++) {
          const x = (width / treeCount) * i + (width / treeCount) / 2;
          const treeWidth = 20;
          const trunkHeight = 40;

          // Trunk
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(x - treeWidth / 4, height - floorHeight - trunkHeight, treeWidth / 2, trunkHeight);

          // Simple foliage
          ctx.beginPath();
          ctx.fillStyle = "#228B22";
          ctx.arc(x, height - floorHeight - trunkHeight, 30, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Start the game
    window.onload = () => {
      const canvas = document.getElementById("gameCanvas");
      new Game(canvas);
    };
  </script>

</body>

</html>