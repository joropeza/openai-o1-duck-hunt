<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Duck Hunt Marsh (Square)</title>
  <style>
    /* Container to limit width to 800px */
    .game-container {
      max-width: 800px;
      margin: 0 auto;
      border: 2px solid #555;
      position: relative;
    }

    /* Let JavaScript control the exact canvas dimensions for 1:1 aspect ratio */
    canvas {
      display: block;
      width: 100%;
      cursor: none;
      /* We'll draw a custom crosshair */
    }

    body {
      margin: 0;
      padding: 0;
      background: #eee;
      font-family: sans-serif;
    }
  </style>
</head>

<body>

  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>

  <script>
    /** 
     * Gun class to handle aiming and firing.
     */
    class Gun {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.isFiring = false;
        this.flashTimer = 0;
        this.flashDuration = 200; // milliseconds
      }

      update(deltaTime) {
        if (this.isFiring) {
          this.flashTimer -= deltaTime;
          if (this.flashTimer <= 0) {
            this.isFiring = false;
            this.flashTimer = 0;
          }
        }
      }

      fire() {
        this.isFiring = true;
        this.flashTimer = this.flashDuration;
      }

      setPosition(x, y) {
        this.x = x;
        this.y = y;
      }

      draw(ctx) {
        ctx.save();
        ctx.strokeStyle = this.isFiring ? "red" : "black";
        ctx.lineWidth = 2;

        const size = 20;
        // Crosshair lines
        ctx.beginPath();
        ctx.moveTo(this.x - size, this.y);
        ctx.lineTo(this.x + size, this.y);
        ctx.moveTo(this.x, this.y - size);
        ctx.lineTo(this.x, this.y + size);
        ctx.stroke();

        // Small circle in the center
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      }
    }

    /**
     * Duck class for creating and updating a flying duck with a sprite.
     * Now includes a distance dimension, 30–200 ft.
     * Ducks at 50 ft = original size (50×50). 
     * Ducks at 200 ft are scaled smaller, at 30 ft are scaled bigger.
     */
    class Duck {
      static duckImage = null;

      constructor(canvasWidth, canvasHeight) {
        // Load the duck image once as a static property
        if (!Duck.duckImage) {
          Duck.duckImage = new Image();
          Duck.duckImage.src = "https://seeklogo.com/images/D/Duck_Hunt-logo-8044A0A3B6-seeklogo.com.png";
        }

        // Random flight direction
        // true => left->right, false => right->left
        this.flyRight = Math.random() < 0.5;

        // Position the duck at a random Y in the top 1/3 of the canvas
        const topThird = canvasHeight * 0.33;
        this.y = 25 + Math.random() * (topThird - 50);

        // Horizontal position just offscreen on either left or right
        this.x = this.flyRight ? -50 : canvasWidth + 50;

        // Choose a random speed between 0.2 and 0.4 px/ms (200–400 px/s)
        const speed = 0.2 + Math.random() * 0.2;
        this.vx = this.flyRight ? speed : -speed;

        // Choose a random distance between 30 and 200 feet
        this.distance = 30 + Math.random() * 170;

        // Use the current size (50×50) for 50 ft.
        // Scale proportionally at other distances:
        // scale = referenceDist / distance => referenceDist=50 ft
        // finalSize = 50 * scale
        const baseSize = 50;
        const referenceDist = 50; // feet
        const scale = referenceDist / this.distance; // e.g. 50/200=0.25 => smaller
        this.width = baseSize * scale;
        this.height = baseSize * scale;

        this.alive = true; // Mark if this duck is still active
      }

      update(deltaTime, canvasWidth) {
        // Move horizontally
        this.x += this.vx * deltaTime;

        // If the duck has gone fully off-screen, mark it inactive
        if (this.flyRight && this.x > canvasWidth + 50) {
          this.alive = false;
        } else if (!this.flyRight && this.x < -100) {
          this.alive = false;
        }
      }

      draw(ctx) {
        // If the image isn't loaded yet, do nothing
        if (!Duck.duckImage.complete) return;

        ctx.save();
        // Translate to the duck's position
        ctx.translate(this.x, this.y);

        if (!this.flyRight) {
          // Flip horizontally if flying left
          ctx.scale(-1, 1);
        }
        // Draw the duck so that its center is at (0,0) after transform
        ctx.drawImage(
          Duck.duckImage,
          -this.width / 2,
          -this.height / 2,
          this.width,
          this.height
        );
        ctx.restore();
      }
    }

    /**
     * Shell class (placeholder).
     */
    class Shell {
      constructor() { }
      update(deltaTime) { }
      draw(ctx) { }
    }

    /** 
     * Main Game class
     */
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.lastTime = 0;

        this.gun = new Gun();
        this.shells = [];
        this.ducks = [];

        // For duck spawning
        this.duckSpawnTimer = 0;
        this.nextDuckSpawnTime = this.randomSpawnTime(); // ms between 3–7 s

        // Mouse events
        canvas.addEventListener("mousemove", (e) => this.onMouseMove(e));
        canvas.addEventListener("mousedown", (e) => this.onMouseDown(e));

        // Keep canvas square
        this.resizeCanvas();
        window.addEventListener("resize", () => this.resizeCanvas());

        // Start loop
        requestAnimationFrame((time) => this.gameLoop(time));
      }

      randomSpawnTime() {
        // 3,000 to 7,000 ms
        return 3000 + Math.random() * 4000;
      }

      resizeCanvas() {
        const containerRect = this.canvas.parentNode.getBoundingClientRect();
        const size = containerRect.width; // keep the canvas square
        this.canvas.width = size;
        this.canvas.height = size;
      }

      onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.gun.setPosition(x, y);
      }

      onMouseDown(e) {
        this.gun.fire();
        // Could check if crosshair hits a duck, etc.
      }

      gameLoop(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame((time) => this.gameLoop(time));
      }

      update(deltaTime) {
        // Update gun flash
        this.gun.update(deltaTime);

        // Update spawn timing
        this.duckSpawnTimer += deltaTime;
        if (this.duckSpawnTimer >= this.nextDuckSpawnTime) {
          this.spawnDuck();
          this.duckSpawnTimer = 0;
          this.nextDuckSpawnTime = this.randomSpawnTime();
        }

        // Update ducks
        this.ducks.forEach((duck) => duck.update(deltaTime, this.canvas.width));
        // Remove offscreen ducks
        this.ducks = this.ducks.filter((duck) => duck.alive);

        // Update shells (placeholder)
        this.shells.forEach((shell) => shell.update(deltaTime));
      }

      spawnDuck() {
        const newDuck = new Duck(this.canvas.width, this.canvas.height);
        this.ducks.push(newDuck);
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Background
        this.drawBackground();
        // Trees
        this.drawTrees();

        // Ducks
        this.ducks.forEach((duck) => duck.draw(this.ctx));

        // Gun crosshair
        this.gun.draw(this.ctx);
      }

      drawBackground() {
        const { width, height } = this.canvas;
        const ctx = this.ctx;

        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, "#72c2f2");
        skyGradient.addColorStop(0.7, "#b3ecff");
        skyGradient.addColorStop(1, "#ffffff");
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);

        // Grass
        const floorHeight = height * 0.3;
        ctx.fillStyle = "#5cbb4e";
        ctx.fillRect(0, height - floorHeight, width, floorHeight);
      }

      drawTrees() {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const treeCount = 5;
        const floorHeight = height * 0.3;

        for (let i = 0; i < treeCount; i++) {
          const x = (width / treeCount) * i + (width / treeCount) / 2;
          const treeWidth = 20;
          const trunkHeight = 40;

          // Trunk
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(x - treeWidth / 4, height - floorHeight - trunkHeight, treeWidth / 2, trunkHeight);

          // Foliage
          ctx.beginPath();
          ctx.fillStyle = "#228B22";
          ctx.arc(x, height - floorHeight - trunkHeight, 30, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Start the game
    window.onload = () => {
      const canvas = document.getElementById("gameCanvas");
      new Game(canvas);
    };
  </script>

</body>

</html>